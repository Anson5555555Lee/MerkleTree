<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Understanding Merkle Trees</title>
</head>

<body>

<p>Understanding Merkle Trees</p>
<p>Why use them, who uses them, and how to use them</p>
<h2>Introduction</h2>
<p>In 1979, Ralph Merkle<sup>1</sup> patented<sup>3</sup> the concept of hash 
trees, or better known as a Merkle tree (the patent expired in 
2002.)&nbsp; In summary: <i>&quot;The invention comprises a method of providing a 
digital signature for purposes of authentication of a message, which utilizes an 
authentication tree function of a one-way function of a secret number.&quot;</i>&nbsp; 
</p>
<p>Or, if you prefer wikipedia's definition: &quot;<i>In cryptography and computer 
science, a hash tree or Merkle tree is a tree in which every non-leaf node is 
labeled with the hash of the labels or values (in case of leaves) of its child 
nodes. Hash trees allow efficient and secure verification of the contents of 
large data structures. Hash trees are a generalization of hash lists and hash 
chains.</i>&quot;<sup>2</sup></p>
<h3>Terminology in This Article</h3>
<p>I'll attempt to use a consistent terminology throughout this article, except 
where directly quoting some reference material.</p>
<p><u>Record</u> - a boring word that describes a packet of data whose hash 
corresponds to a &quot;leaf&quot; in a Merkle tree.&nbsp; When reading about Merkle trees, 
you'll see other words like &quot;transaction&quot; or &quot;certificate&quot; depending on the 
context. </p>
<p><u>Block</u> - borrowing from bitcoin, I'm going to use the term &quot;block&quot; to 
mean <i>all the permanent records</i> that&nbsp; representing the leaves of the 
Merkle tree.&nbsp; To quote bitcoin:&nbsp; &quot;Transaction data is permanently 
recorded in files called blocks. They can be thought of as the individual pages 
of a city recorder's recordbook (where changes to title to real estate are 
recorded) or a stock transaction ledger.&quot;<sup>8</sup>&nbsp; In other words: 
&quot;records are permanently recorded in files called blocks.&quot;</p>
<p><u>Log</u> - synonymous for the Merkle tree, a log is the hash tree 
constructed from the hashed records.&nbsp; In addition to the log being 
represented as a hash tree, the log has a specific property: new entries are 
always appended as a new leaf (or leaves) to the last leaf in the tree.&nbsp; 
Furthermore, for transactional systems (like currencies), once a record is 
&quot;logged&quot;, it cannot be changed--instead, changes to the transaction are 
represented as new record entries in the log, providing a complete audit trail 
of a transaction.&nbsp; Conversely, a distributed datastore (like a NoSQL 
database) where a record is allowed to change will update the hash of the record 
and thus the entire tree.&nbsp; In this scenario, a Merkle tree is used to 
quickly and efficiently identify the changed record so that nodes in the 
distributed system can be synchronized.</p>
<h2>Why Merkle Trees?</h2>
<p>Merkle trees (and variations) are used by Bitcoin<sup>4</sup>, Ethereum<sup>6</sup>, Apache 
Cassandra<sup>5</sup>, and 
other systems to provide:</p>
<ul>
	<li>consistency verification</li>
	<li>data verification</li>
	<li>data synchronization</li>
</ul>
<p>What do these terms mean?</p>
<h3>Consistency Verification</h3>
<p>This is known as a &quot;consistency proof&quot; because it lets you verify that any 
two versions of a log are consistent:</p>
<ol>
	<li>the later version includes everything in the earlier version</li>
	<li>...in the same order</li>
	<li>...and all new records come after the records in the older version<sup>7</sup></li>
</ol>
<p>&quot;If you can prove that a log is consistent it means that:</p>
<ul>
	<li>no certificates [records] have 
been back-dated and inserted into the log</li>
	<li>no certificates have been modified in 
the log,</li>
	<li>and the log has never been branched or forked.&quot;<sup>7</sup></li>
</ul>
<p>A consistency proof is therefore important for verifying that your log has 
not been corrupted.&nbsp; &quot;Monitors and auditors regularly use consistency 
proofs to verify that logs are behaving properly.&quot;<sup>7</sup></p>
<h3>Data Verification</h3>
<p>This is known as an &quot;audit proof&quot; because it lets you verify that a specific 
record has been included in the log.&nbsp; As with the consistency verification, 
the server maintaining the log provides the client with a proof that the record 
exists in the log.&nbsp; &quot;Anyone can request a Merkle audit proof from a log and 
verify that a certificate [record] is in the log. Auditors routinely send these 
types of requests to logs so they can verify certificates for TLS clients. If a 
Merkle audit proof fails to produce a root hash that matches the Merkle tree 
hash, it means the certificate is not in the log.&quot;<sup>7</sup> (More on what a 
root has is and how an audit proof works later on.)&nbsp; </p>
<p><img border="0" src="key-small.png" width="94" height="33"></p>
<p>But there's another reason for sending the proof to the client: it proves 
that the server itself is not inventing a positive answer, but is instead 
proving to you, the client, that it knows what it's talking about.&nbsp; Faking 
a proof is computationally impossible.&nbsp;&nbsp; </p>
<h3>Data Synchronization</h3>
<p>Merkle trees are useful in synchronizing data across a distributed data store 
because it allows each node in the distributed system to quickly and efficiently 
identify records that have changed without having to send all the data to make 
the comparison.&nbsp; Instead, once a particular leaf in the tree is identified 
as having been changed, only the record that is associated with that specific 
leaf is sent over the network.&nbsp; Note that Merkle trees do not directly 
provide mechanisms for resolving collisions and synchronizing multiple writers 
to the same record.&nbsp; We'll demonstrate how this works later on.</p>
<h3>Proof is Critical</h3>
<p><img border="0" src="key-small.png" width="94" height="33"></p>
<p>Critical to the concept of a consistency proof and an audit proof is that 
there actually is a proof that the client can verify on its own.&nbsp; This 
means that when the client queries a server (ideally a trusted authority) to 
validate consistency or the existence of a transaction, the server doesn't just 
respond with a &quot;yes&quot; or &quot;no&quot; answer, but, in the case of a &quot;yes&quot;, sends you back<i>
a proof</i> that the client can verify.&nbsp; The proof is based on the server's 
knowledge of the Merkle tree, which cannot be duplicated by someone trying to 
get the client to believe that their data is valid.</p>
<p>In a distributed system, each node maintains the Merkle tree for its data, 
and during the synchronization process, any node indicating that a record has 
changed ends up implicitly proving itself to the other nodes that it is a valid 
node.&nbsp; In other words, a node cannot jump onto the network and say &quot;I have 
a new record&quot; or &quot;I have a record to replace this other record&quot; because it is 
lacking the information necessary to prove itself to the other nodes.</p>
<h2>Merkle Trees in Action</h2>
<p>A Merkle tree is typically a binary tree in which each leaf represents the 
hashed value of the record associated with that leaf.&nbsp; The branches are the 
hash of the concatenated hashes of the two children.&nbsp; This process of 
re-hashing the concatenation of the child nodes to create the parent node is 
performed until the top of the tree is reached, called the &quot;root hash.&quot;</p>
<p><img border="0" src="tree1.png" width="796" height="226"></p>
<p>The above diagram simulates the concatenation of the child hashes.</p>
<h3>How Does Data Verification (Audit Proof) Work?</h3>
<p>Let's say you are the owner of the record &quot;2&quot; in the above diagram.&nbsp; You 
also have, from a trusted authority, the root hash, which in our simulation is 
&quot;01234567&quot;.&nbsp; You ask the server to prove to you that your record &quot;2&quot; is in 
the tree.&nbsp; What the server returns to you are the hashes &quot;3&quot;, &quot;01&quot;, &quot;4567&quot; 
as illustrated here:</p>
<p><img border="0" src="consistency1.png" width="644" height="221"></p>
<p>Using this information (including the right-left flags that are sent back 
along with the hashes), the proof is that:</p>
<ul>
	<li>2 + 3 from which you compute 23</li>
	<li>01 + 23 from which you compute 0123</li>
	<li>0123 + 4567 from which you compute 01234567</li>
</ul>
<p>Since you know the root hash from your trusted authority, the proof validates 
that &quot;2&quot; exists in the tree.&nbsp; Furthermore, the system from which you have 
obtained the proof is proving to you that it is an &quot;authority&quot; because it is 
able to provide valid hashes so that you can get from &quot;2&quot; to your known root 
hash &quot;01234567.&quot;&nbsp; Any system pretending to validate your request would not 
be able to provide you with the intermediate hashes since you're not giving the 
system the root hash, you're just telling it to give you the proof - it can't 
invent the proof because it doesn't know your root hash -- only you know that.</p>
<p>In order to verify the proof, very little information about the tree is 
revealed to you.&nbsp; Furthermore, the data packet that is needed for this 
proof is very small, making it efficient to send over a network and to make the 
proof computation.</p>
<h3>How Does Consistency Verification (Consistency Proof) Work?</h3>
<p>Consistency proofs apply to trees that are &quot;append only&quot;, like a log.&nbsp; 
They are typically not used in systems where leaves are being updated because 
this would require synchronizing old root hash values.&nbsp; It's doable, it's 
just not something I would expect to see.&nbsp; Section 2.1.3 of RFC 6962<sup>9</sup> 
provides some useful diagrams on how a consistency proof works, but I found it 
confusing to figure out, so I'll try and explain it a bit better here.&nbsp; 
Using their example (but my simulated hash numbering), we'll start with 3 
records:</p>
<p>First three records &quot;012&quot; are created:</p>
<p><img border="0" src="r1.png" width="283" height="161"></p>
<p>A fourth record &quot;3&quot; is added at some point, resulting in this tree:</p>
<p><img border="0" src="tree3.png" width="325" height="164"></p>
<p>Two more records &quot;45&quot; are added:</p>
<p><img border="0" src="r2.png" width="531" height="224"></p>
<p>And finally, one more record &quot;6&quot; is added:</p>
<p><img border="0" src="r3.png" width="606" height="219"></p>
<p>For each of the sub-trees (record sets) we appended:</p>
<p>012<br>
3<br>
45<br>
6</p>
<p>we have root hashes for the tree after the sub-tree was appended.&nbsp; We 
now want to verify the root hashes when those sub-trees were added can be 
reconstructed, even though the full tree's root hash has changed.&nbsp; This 
verifies the order of the records and that the data associated with the record's 
hash hasn't changed, either on the authority server or the client's machine.</p>
<h4>Consistency Proof Walkthrough</h4>
<p>A consistency proof recreates the hashes 
for each sub-tree given the new tree (last figure above):</p>
<ol>
	<li>The first tree has a root hash of &quot;012&quot;.</li>
	<li>When the second tree was added, the root hash became &quot;0123&quot;.</li>
	<li>When the third tree was added, the root hash changed to &quot;012345&quot;.</li>
	<li>When the last tree was added, the root hash changed to &quot;0123456&quot;. </li>
</ol>
<p><u>Consistency Proof of the First Tree</u></p>
<p>What do we need to do to verify that the first tree, with its 3 leaves, still 
exists in the new tree?</p>
<p><img border="0" src="consistency7.png" width="647" height="224"></p>
<p>As the above diagram illustrates, we need the hashes of 2 nodes &quot;01&quot; and &quot;2&quot; 
in order to reconstruct the first tree's old root has of &quot;012&quot;.</p>
<p><u>Consistency Proof of the Second Tree</u></p>
<p>The root hash when we added the second tree, which appended one leaf &quot;3&quot; 
for a total of 4 leaves now in the tree, was the 
hash for the node &quot;0123&quot;.</p>
<p>&nbsp;</p>
<p>The consistency proof is simply the node that represents &quot;0123&quot;.</p>
<p><u>Consistency Proof of the Third Tree</u></p>
<p>The third tree added two nodes &quot;45&quot; and the root hash at that point was 
&quot;012345&quot;.&nbsp; The consistency proof obtains that for us:</p>
<p><img border="0" src="consistency3.png" width="648" height="224"></p>
<p><u>Consistency Proof Another Scenario</u></p>
<p>Let's say we added leaves &quot;4&quot;, &quot;5&quot;, and &quot;6&quot; separately.&nbsp; When we added 
the leaf for &quot;4&quot;, we were given the hash for the node &quot;01234&quot; for the 5 leaves 
in the tree at that point.&nbsp; Now that we have 7 leaves in the tree, here's 
the pieces needed to reconstruct the old root hash of &quot;01234&quot;:</p>
<p><img border="0" src="consistency4.png" width="644" height="227"></p>
<p><u>Consistency Proof Last Scenario</u></p>
<p>This scenario differs from all the rest because three nodes are required to 
construct the original root hash.&nbsp; Given a tree with 8 leaves, where the 
7th leaf (node &quot;6&quot;) was added, the root hash at that point was the hash for 
&quot;0123456&quot;.&nbsp; The reconstruction of this hash requires these nodes:</p>
<p><img border="0" src="consistency5.png" width="645" height="219"></p>
<h4>Reconstructing the Old Root Hash</h4>
<p>The last example above illustrates how the old root hash &quot;0123456&quot; is 
reconstructed from the the list of nodes in the consistency proof.&nbsp; Here, 
the nodes are given to us in the following order:</p>
<p>0123<br>
45<br>
6</p>
<p>To reconstruct the old hash, we have to combine hashes from right to left:</p>
<p>45 + 6 = 456<br>
0123 + 456 = 0123456</p>
<h4>Consistency Proof Caveats</h4>
<p>This is not a trivial algorithm and uses the following rules and information:</p>
<ul>
	<li>A consistency proof is always based on a computation verifying the first
	<i>m</i> leaves in the tree.&nbsp; When we add a tree to an existing tree,
	<i>m</i> is the number of leaves after the trees have been combined.&nbsp; 
	This is a requirement because you want to make sure that all the hashes of 
	the data verify order and have not mutated.</li>
	<li>However, by knowing the number of leaves that represented the 
	intermediate root hash, the algorithm can quickly identify the specific node 
	that consists of either:<ul>
		<li>the matching hash (if the number of leaves is a power of 2).</li>
		<li>the child pairs needed to reconstruct the intermediate root hash.</li>
	</ul>
	</li>
	<li><img border="0" src="important.png" width="38" height="32">&nbsp; This 
	implies that when a tree is added to the &quot;log&quot; (existing set of records), 
	the number of leaves now present in the tree is retained along with the root 
	hash.</li>
	<li>In many cases, where one particular system is solely responsible for 
	appending trees, this is simple because the system of course knows how many 
	leaves are in each tree it is adding.</li>
	<li>In a distributed system, where there can be other participants appending 
	trees (along with the added complexity of preventing simultaneous append 
	operations) the participant adding the tree needs to be informed as to the 
	number of leaves in the tree so that a consistency check can be performed 
	later.&nbsp; </li>
	<li>To avoid this extra knowledge, the maintainer of the full Merkle tree 
	can utilize a dictionary mapping tree roots that were appended to leaf 
	counts.&nbsp; This is probably a more secure way of managing the required 
	information.</li>
</ul>
<p>On the other hand, the algorithm is very efficient because it begins with the 
leftmost node at the level that is log<sub>2</sub>(<i>m</i>).&nbsp; This avoids 
having to compute the hashes for potentially thousands of leaves starting from 
the first leaf, but still guarantees that if the resulting proof matches the 
hash when the tree was appended, the order of the records and the records 
themselves are valid. </p>
<h4>Consistency Proof General Algorithm</h4>
<p>You can read through the consistency proof in section 2.1.2 of RFC 6962<sup>9</sup>, 
or you can just go with this:</p>
<p><b>Rule 1</b>: Find the leftmost node of the tree from which we can start our 
consistency proof.&nbsp; Usually, this will be a node representing a piece (the 
left piece) of the hash needed to obtain the old root hash.</p>
<p>Given <i>m</i>, the number of leaves in the master tree after a sub-tree was 
added, take <i>n</i>=log<sub>2</sub>(<i>m</i>) to find the index of the node 
representing at most<i> m</i> leaves.&nbsp; This index is the left-branch 
traversal up the tree, starting from the leftmost leaf, of the tree.</p>
<p>For example:</p>
<p>3 leaves: log<sub>2</sub>(3) = 1.58 (we start at node &quot;01&quot;)<br>
4 leaves: log<sub>2</sub>(4) = 2 (we start at node &quot;0123&quot;)<br>
6 leaves: log<sub>2</sub>(6) = 2.58 (we start at node &quot;0123&quot;)</p>
<p>This gives you the index (rounded down) of the node whose hash you start 
with.&nbsp; By starting at the correct level, we know that the sub-tree starts 
at this position or is a composite -- if there's a remainder of log<sub>2</sub>(<i>m</i>) 
-- of the current node's hash and the hash of a sibling node.&nbsp; This diagram 
should help (note that level 3 is actually not representing 8 leaves, because 
all 8 leaves haven't been added yet):</p>
<p><img border="0" src="r4.png" width="603" height="221"></p>
<p>Also, set <i>k</i>, the number of leaves for this node (<u>nodes have to 
compute their leaf count because the last leaf of a tree might be missing.</u>)</p>
<p>Also set the initial sibling node (SN) to the sibling of the node acquired by 
Rule 1, if it exists.</p>
<p>if m-k == 0, proceed with rule 3.</p>
<p>Three scenarios using the above diagram:</p>
<p>m of 2: index = 1 (the &quot;01&quot; node) and it has 2 leaves, so we move on to rule 
3.</p>
<p>m of 4: index = 2 (the &quot;01234&quot; node), and it has 4 leaves, so we move on to 
rule 3.</p>
<p>m of 3: index = 1 (&quot;the &quot;01&quot; node) and it has 2 leaves, but m-k = 1, so we 
move on to rule 2.</p>
<p><b>Rule 2</b>:&nbsp; </p>
<p>if m-k == # of SN's leaves, concatenate the hash of&nbsp; SN and exit 
Rule 2, as this represents the hash of the old root.</p>
<p>if m-k &lt; # of SN's leaves, set SN to SN's left child node and repeat Rule 2.</p>
<p>if m-k &gt; # of SN's leaves, concatenate the hash of SN, increment k by SN's # 
of leaves, and set SN to its parent's right node.</p>
<p>In this manner, we always end of with the hashes from which we can 
reconstruct the old root hash.</p>
<p>A few scenarios:</p>
<p><b>m = 3</b>.&nbsp; k=2 (the number of leaves under &quot;01&quot;), SN = &quot;23&quot;<br>
SN's # of leaves is 2.&nbsp; m-k &lt; 2, so SN = left child of SN, which is &quot;2&quot;<br>
SN's # of leaves is 1(well, it <u>is</u> a leaf)<br>
m-k = SN's # of leaves, so we know to use the hash for &quot;01&quot; plus the hash for 
&quot;2&quot; to construct the old root &quot;012&quot;.</p>
<p><b>m = 4</b> is handled by rule 1</p>
<p><b>m = 5</b>. k=4 (the number of leaves under &quot;0123&quot;).&nbsp; SN=&quot;456&quot;<br>
SN's # of leaves is 3.<br>
m-k &lt; SN's # of leaves, so SN = left child of SN, which is &quot;45&quot;<br>
SN's # of leaves is now 2<br>
m-k &lt; SN's # of leaves, so SN = left child of SN, which is &quot;4&quot;<br>
SN's # of leaves is now 1 (it's a leaf)<br>
m-k = SN's # of leaves, so we know to use the hash for &quot;0123&quot; plus the hash for 
&quot;4&quot; to construct the old root &quot;01234&quot;.</p>
<p>This is a good example of constructing a consistency tree for any number of 
leaves starting from the first leaf, whether the old root was part of a tree 
that was added to the master tree or not.&nbsp; However, this is not the typical 
scenario.&nbsp; Moving along:</p>
<p><b>m = 6</b>. k=4 (the number of leaves under &quot;0123&quot;).&nbsp; SN=&quot;456&quot;<br>
SN's # of leaves is 3.<br>
m-k &lt; SN's # of leaves, so SN = left child of SN, which is &quot;45&quot;<br>
SN's # of leaves is now 2.<br>
m-k - SN's # of leaves, so we know to use the hash for &quot;0123&quot; plus the hash for 
&quot;45&quot; to construct the old root &quot;012345&quot;.</p>
<p><b>m = 7</b>. k=4 (the number of leaves under &quot;0123&quot;).&nbsp; SN=&quot;456&quot;<br>
m-k = SN's # of leaves, so we know to use the hash for &quot;0123&quot; plus the hash for 
&quot;456&quot; to construct the existing root &quot;0123456&quot;</p>
<p><b>Rule 3</b>: The remainder of the proof, from which can derive the current 
root hash, involves:</p>
<p>a: concatenating the last hash with the right sibling (if it exists) of the 
last hash to obtain the parent hash.&nbsp; </p>
<p>b: Continue with the audit proof (using the appropriate left or right 
sibling) until the sibling whose hash is the first hash in the proof is 
obtained.&nbsp; This is basically a verification that that hash (the first hash 
in the proof) is encountered and should always be the left sibling.&nbsp; </p>
<p>c: Combine the two hashes and continue with the audit proof until the root 
node is encountered, whose hash should be the same as the current tree's hash.</p>
<p>For example, given this consistency proof to the old hash for the tree 
representing &quot;01234&quot; (this is the more interesting example):</p>
<p><img border="0" src="consistency6.png" width="648" height="223"></p>
<p>The nodes involved in the remainder of the proof, so that we obtain the root 
hash, are the hashes of the nodes &quot;5&quot; and &quot;67&quot;.&nbsp; We need &quot;5&quot; to obtain 
&quot;45&quot;, and we need &quot;67&quot; to obtain &quot;4567&quot;.&nbsp; Interesting, isn't it!</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Serialization</h2>
<h3>The Merkle Tree</h3>
<h3>The Audit Proof</h3>
<h3>The Consistency Proof</h3>
<p>&nbsp;</p>
<h2>Storage Analysis</h2>
<p>Merkle trees present a memory/disk space efficient way to store the 
information for validating records.&nbsp; The data required to validate a proof 
is also very efficient.</p>
<p>todo - fill in with some analysis.</p>
<h2>Merkle Tree Implementation</h2>
<h4>Hash Provider</h4>
<h2>Unit Tests</h2>
<h2>The Demo App</h2>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Conclusion</h2>
<p>Writing this article was definitely the embodiment of the experience &quot;you 
only understand it if you can teach it.&quot;&nbsp; It took a lot of research and 
digging to understand not just the algorithms, specifically for the consistency 
proof.&nbsp; More importantly, understanding the &quot;why&quot; was not intuitively 
obvious.&nbsp; I ended up doing a mental Q&amp;A session with myself, which I 
decided to add here just so you can see what my basic questions were and how I 
decided to answer them, at least for myself.&nbsp; Some of these answer may not 
be very good, some may go down unnecessary rabbit holes, etc., so keep in mind 
that this represents a snapshot of my own investigation before even starting 
this article.</p>
<p>Data Synchronization Q&amp;A</p>
<ul>
	<li>As the &quot;client&quot;, you're downloading a large file, say 10GB, spread 
	across peers in chunks of 4096 bytes.</li>
	<li>You need a trusted authority server to tell you whether each block is 
	valid.</li>
	<li>From the server, you can be given the root hash and, as each block comes 
	in, you start filling in the Merkle tree yourself. </li>
	<li><u>However, you'll need all the data downloaded before you can complete 
	the tree to verify the root.</u></li>
	<li>Instead, you can ask the server to send you the path of a hashed chunk 
	(the leaf) to the root hash and verify it yourself. This enables you to 
	verify each chunk and if it is faulty, request it from somewhere else, 
	simultaneously while you are downloading other chunks. Furthermore, you're 
	not maintaining all the hashes of the chunks and building the entire Merkle 
	tree yourself. So it's faster for verifying a chunk, and it's less memory on 
	your part to hold the entire Merkle tree.</li>
	<li>The server (as trusted authority) doesn't hold the data, but it has to 
	have the Merkle tree, including leaf hashes.</li>
</ul>
<p>With regards to data synchronization, you basically have three options:</p>
<ol>
	<li>Download all the data so you can verify the Merkle root hash</li>
	<li>Download from a trusted authority the Merkle tree so you can test with 
	an incomplete recordset.</li>
	<li>Ask the server to perform an audit proof on a particular leaf.</li>
</ol>
<p>Validation Q&amp;A:</p>
<p>Q1: Why not just ask the server if the leaf exists in tree with the specific 
root?</p>
<p>Q2: Why should the server even bother with storing a Merkle tree of the leaf 
hashes? (see answer to Q4 as well)</p>
<p>A1: You could do that, but the SHA256 hash is only 32 bytes, and while this 
represents a huge number of unique hashes (2^256), 1.15*10^77, hashing node pair 
hashes as we walk up the tree strongly validates that the hash under question 
belongs to the correct tree.&nbsp; Furthermore, the audit proof verifies the 
particular order of the record in relationship to the other leaves.&nbsp; <u>We 
don't just want to know that a leaf exists, we want to verify that it exists in 
a particular location in the tree.</u></p>
<p>A2: Let's say you have a large dataset divided into small chunks. First, you 
may not be maintaining the entire dataset but only the portion you are 
responsible for. If a change occurs in that chunk, you can recalculate the root 
hash knowing only the left-right branches to the root.</p>
<p>The side-effect to this is that you also only need to maintain the left-right 
branches for your chunks, rather than the entire Merkle tree (including all the 
leaf hashes of chunks that you don't know or care about.)</p>
<p>To synchronize, another user asks you to verify your root hash against their 
root hash. If different, the left/right child hashes are requested, and the 
process iterates the mismatches until the chunks on your end that have changed 
are identified. Now you only send your changed chunk to the other user, and you 
are both synchronized again.</p>
<p>Detect Collisions Q&amp;A</p>
<p>Q3: What happens if more than one user modifies the same chunk (based on the 
idea that in a distributed system, you want to replicate the data across many 
peers for resiliency.)</p>
<p>A1: Only one peer may have the authority to change the data</p>
<p>A2: Hashes can be time stamped, and you accept only the most recent change, 
discarding anything else</p>
<p>A3: Differences are merged (either automatically or requiring manual 
intervention.)</p>
<p>A4: You accept only the oldest change, and discard anything more recent</p>
<p>A5: Technically, a chunk should never be changed. If a change is required, 
this should be logged as a new transaction so that there is an auditable trail 
of changes (not the same think as a Merkle audit). Given that, only specified 
authorities should be allowed to modify a transaction.</p>
<p>A6: Some sort of blocking mechanism might be used to prevent data from being 
modified simultaneously. For example, you could be given a &quot;change key&quot; and when 
you submit the change, if your change key doesn't match the current change key, 
your change is rejected, requiring you to syncrhonize your data, acquire a new 
change key, and submit your changes again.</p>
<p>A7: The salient point to this is that, if the chunk sizes are small, the 
likelihood that your change will collide with someone else's is small.</p>
<p>Why Proofs Q&amp;A</p>
<p>Q4: Why should the server send you the hash audit trail of to verify a chunk, 
rather than just sending you a &quot;yes/no&quot; response?</p>
<p>A: This is your way of verifying that the server hasn't been compromised -- 
if it simply said &quot;yes&quot;, how would you know you can trust it? By sending you the 
left-right hashes, the server is telling you &quot;here is how I verified your 
request.&quot; A server that is trying to get you to believe your chunk has is valid 
cannot send you &quot;any&quot; audit trail hash because that would give a different root 
hash.<br>
&nbsp;</p>
<p>&nbsp;</p>
<h2>References</h2>
<p><sup>1</sup> - <a href="https://en.wikipedia.org/wiki/Ralph_Merkle">Ralph 
Merkle</a><br>
<sup>2</sup> - <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle Tree</a><br>
<sup>3</sup> - <a href="https://www.google.com/patents/US4309569">Method of 
providing digital signatures, patent US 4309569 A</a><br>
<sup>4</sup> -
<a href="https://bitcoin.org/en/developer-guide#block-chain-overview">Bitcoin 
Developer Guide - Block Chain</a><br>
<sup>5</sup> -
<a href="http://distributeddatastore.blogspot.com/2013/07/cassandra-using-merkle-trees-to-detect.html">
Cassandra's AntiEntropy service</a><br>
<sup>6</sup> -
<a href="https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/">Merkling in 
Ethereum</a><br>
<sup>7</sup> - <a href="http://www.certificate-transparency.org/log-proofs-work">
Consistency Proofs and Audit Proofs</a><br>
<sup>8</sup> - <a href="https://en.bitcoin.it/wiki/Block">bitcoin block</a><br>
9 - <a href="https://tools.ietf.org/html/rfc6962">RFC6962 - Certificate 
Transparency</a></p>
<p>&nbsp;</p>

</body>

</html>